#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Knuteon!
# Copyright (C) 2019 by Sven Kochmann

# Program name was generated by chem-name-gen, see 
# DOI: 10.5281/zenodo.2578429

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the  Free Software Foundation,  either version 3  of the License, or
# (at your option) any later version.

# This program  is distributed  in the hope  that it will  be  useful,
# but  WITHOUT  ANY  WARRANTY;  without even  the implied warranty  of
# MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the
# GNU General Public License for more details.

# You  should  have  received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# This program extracts the data lines from Karat32 data files.  These
# data files are simple OLE files with the following structure:
# 
# experiment.dat
# 	|-> AuditTrail
# 	|-> Baseline Check
# 	|-> ChangeLog
# 	|-> Detector Data          <-- the folder with the detector traces
# 	|-> MethodXX
# 	|-> Results
# 	|-> Signature
# 	|-> XY Data
# 	[5]SummaryInformation
# 	3D Data
# 	3D Trace Handler
# 	Chrom Header		       <-- header file containing general info
#	Contents				   <-- list of traces
#	Detector Trace Handler
#	Extra Sequence Columns
#	FileValidation
#	Multichromatogram Info
#	ResultEntries
#	XY Trace Handler

# Imports
import argparse
import datetime
import math
import olefile
import os
import pwexplode
import struct

# Main program of Knuteon!
def main():
	# Argument setup and parsing
	parser = argparse.ArgumentParser(
				description = 'Knuteon! This program extracts the data from Karat32 data files.')

	parser.add_argument('inputfile', action='store', nargs=1, type=str)

	parser.add_argument('-v', '--version', help = 'prints version information', action='version', version='Knuteon! 1.0 by Sven Kochmann')
	parser.add_argument('-l', '--list', help = 'lists all files and streams in the data file', action='store_true')
	parser.add_argument('-ph', '--print_header', help = 'prints only the header information (chrom header)', action='store_true')

	args = vars(parser.parse_args())

	print(args)

	# Opening of file, reading of header information
	if olefile.isOleFile(args['inputfile'][0]) == False:
		print("%s is not an ole compound file, so it cannot be a Karat32 data file. Sorry." % args['inputfile'][0])
		exit()

	ole = olefile.OleFileIO(args['inputfile'][0])
	basename = os.path.splitext(args['inputfile'][0])[0]

	if args['list']:
		tree = []
		files = ole.listdir(True)

		for item in files:
			tree = add_sublist_to_tree(tree, item)
	
		print(args['inputfile'][0])
		list_data_files(tree, 0)
		print("%d files and streams found." % (len(files)))		
		exit()

	print(basename)
	
	header = read_chrom_header(ole)

	if args['print_header']:
		print(header)
		exit()



######################################################################
# Converts recursively  a list in  the form ['X', 'Y', 'Z', 'file'] to
# a   embeded   list,   which   can  then   be  recursively  shown  by 
# list_data_files (see below)
def add_sublist_to_tree(tree, item):
	if type(item) is not list:
		return tree

	if len(item) == 0:
		return tree

	index = -1
	for i, _ in enumerate(tree):
		if item[0] == tree[i][0]:
			index = i
			break

	if index == -1:
		tree.append([item[0], []])

	if len(item) > 1:
		tree[index][1] = add_sublist_to_tree(tree[index][1], item[1:])

	return tree


######################################################################
# Prints  a directory  structure  of  the  given list;  can be  called 
# recursively with a depth parameter for sublists
def list_data_files(items, depth):
	for item in items:
		if type(item) is not list:
			continue

		print(" " * (1 + depth * 3) + "โณ", end = ' ')

		print(item[0])

		if len(item[1]) > 0:				
			list_data_files(item[1], depth + 1)	
		

######################################################################
# Converts an OLE variant time double to system time and returns it as 
# a datetime object. Math based on the description at
# https://docs.microsoft.com/en-us/dotnet/api/system.datetime.tooadate
def variant_to_system_time(oletime):
	# Date is before the period, the time afterwards; we have to check 
	# for negative times/dates; we add 1e-11 to force double precision
	# for the time part
	datepart = (math.ceil(oletime) if oletime < 0.0 else math.floor(oletime))
	timepart = math.fabs(oletime - datepart + 1e-11)

	if timepart >= 1.0:
		timepart -= 1e-11

	# Convert date part to days, months, and years; the reference date
	# for OLE variant times is December 30, 1899.
	realdate = datetime.datetime(1899, 12, 30) + datetime.timedelta(days=int(datepart))	

	# Time  is  represented  as  fraction  of 24 hours  with .00 being 
	# 0:00 am, .25 being 6:00 am, etc. We just multiply	the value with 
	# 24 hours รก 60 minutes รก 60 seconds  and add it to the date.
	realdate = realdate + datetime.timedelta(seconds=int(timepart * 24 * 3600))

	return realdate


######################################################################
# Reads 'chrom header' from the OLE data file and returns its contents
# as a dictionary
def read_chrom_header(ole):
	headerinfo = {'runtime': datetime.datetime(1899, 12, 30), 'method': '', 'description': '', 
				  'version': '', 'system': '', 'detector': ''}

	chromhead = ole.openstream('Chrom Header')

	# First 8 bytes of this file are unknown, just read to skip
	chromhead.read(8)

	# Next 8 bytes encode the runtime as a double (OLE variant date)
	headerinfo['runtime'] = struct.unpack('<d', chromhead.read(8))[0]
	headerinfo['runtime'] = variant_to_system_time(headerinfo['runtime'])

	# Next  bytes  contain  the strings  for  the method  file,  data
	# description,  version info,  and system info  each encoded as a 
	# C-string (length as a byte + the string itself, max 255 bytes)
	length = struct.unpack('B', chromhead.read(1))[0]
	headerinfo['method'] = chromhead.read(length)

	length = struct.unpack('B', chromhead.read(1))[0]
	headerinfo['description'] = chromhead.read(length)

	length = struct.unpack('B', chromhead.read(1))[0]
	headerinfo['version'] = chromhead.read(length)

	length = struct.unpack('B', chromhead.read(1))[0]
	headerinfo['system'] = chromhead.read(length)

	# Next 22 bytes are unknown, just read to skip
	chromhead.read(22)

	# Detector string encoded as C-String (see above)
	length = struct.unpack('B', chromhead.read(1))[0]
	headerinfo['detector'] = chromhead.read(length)

	return headerinfo


if __name__ == '__main__':
    main()




